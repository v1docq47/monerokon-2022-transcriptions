# Luke Parker (kayabaNerve)

_**Why Multisig Is Important – And How to do it Right**_

_Monero Konferenco  #MoneroKon2022 Day 2_

[https://youtu.be/cOsQtsrQFh8](https://youtu.be/cOsQtsrQFh8)

---

_**Luke:**_ ...In multisig you have five people who are managing the cryptocurrency for your company. You can’t just have one person steal your funds, because you need all five to produce the signature.
Redundancy for threshold signatures you can have a two of three threshold signatures, which I believe a certain company here is offering, and if you lose your key you’ll be able to recover it, because you only need two keys, and two keys are still are there. This means that you can have people die like in the case of Quadriga CX, but unlike the case of Quadriga CX you won’t lose all your funds until your customers you’re broke.

And then there’s also more modern uses. One being atomic swamps, and I’ll get to that in a later slide actually, as well as decentralized custody by protocols, which I also discussed in the in the previous line in the context of decentralized exchanges specifically, and then finally payment channels which Seth just had a great talk on.

Generally payment channels are implemented as a two out of two multisig, for both parties must agree on the stake at any given time using scripts to call back if needed. So for atomic swaps specifically. The Monero atomic swap protocol has people lock up their Bitcoin, but then they lock the Monero into a two out of two multisig. This means both people must agree in order to move the Monero. And that wouldn’t be atomic obviously, if one person goes offline the money’s burned. Because of that Bitcoin script step in and force you ever receive the Bitcoin to reveal their private key. When they reveal the private key the other counterparty can take the two of two multisig, they’ll have the two keys and be able to spend the Monero however they want.

For decentralized exchanges, these generally use threshold multisigs. So they can offer a “t of n” multisig to hold funds, and this means that the funds are secure so long as “t” signers are honest. You can have a hundred nodes, and as long as your threshold is honest it doesn’t matter if the rest go offline, it doesn’t matter if they leave cryptocurrency, it doesn’t matter if they get wiped out, with all that’s going on with Ethereum right now, the network still lasts, and it’s wallet still holds. So the security and decentralization of the funds are equivalent to the network behind the decentralized exchanges.

And this is why I was really hoping to get slides, because now we have some quick maths, it may be a bit overwhelming, but honestly these slides are kind of meant to be downloaded and referred to later. The last kind of two bullet points here are the only important ones, feel free to zone up.

So elliptic curve cryptography. It’s the backbone of modern cryptocurrencies. Monero specifically uses a curve known as ed25519 — there are private keys which I’m sure you know of, technically they’re called scalars and are just very, very large numbers. There’s also public keys technically known as points. Public keys can be added and subtracted along with multiplying against private keys, but they can’t be divided, which is why you can’t get a private key from a public key, and they can’t be multiplied by other public keys. Private key is converted to a public key by multiplying it by a basepoint called ‘G’. So there actually isn’t just a public key of a public key value of 1, we all just took this point, it’s called ‘G,’ and we just said: “Let’s use that as 1”. And now we have public keys. So if you take your private key of ‘X’ you multiply it by ‘G’, and you have a public key. It’s generally written as capital ‘X’, where the capital units it’s a point. So this is where it really gets interesting, and this is the part you actually have to understand.

If you add two public keys together, it’s actually ‘xG’ plus ‘yG’. So the distributive property holds. If you add two public keys, you get the same value as if you added two private keys and then turned it into a public key. This means you can create an ‘n of n’ multisig wallet by adding that together everyone’s public keys, and the private key for the multisig wallet would be the sum of all their private keys. Add it up on one side, adding it up on the other side gives you the same result.

And this gets into the how to do it right part of the talk, because you can add all these keys together, and it’s already insecure. The described scheme, naive sums, is vulnerable to what’s known as “Rogue-Key Attacks”. So Alice, a very honest Alice, creates a private key ‘x’, with a  public key of capital ‘X’, and then send it to Bob. Bob creates a private key of ‘y’, but they send a public key of ‘Y’ minus ‘X’. So Allison’s public key ‘X’ plus Bob’s public key ‘Y’ minus ‘X’ cancels out to ‘Y’, because of that Bob’s public key is now the multisig’s public key, and they just have full control of this. And this was actually noted in a project that hit proof of concept a while ago, and I actually submitted a report to make sure it was fixed.

And the trick here is to use secure key aggregation to stop these attacks. The simplest way is to require Bob to actually prove they know the private key of whatever public key they’re claiming. This is known as the Proof of Possession. They published a public key of ‘Y’ minus ‘X’, so the private key is also ‘y’ minus ‘x’. They know ‘y’ because that’s their private key, but ‘x’ is Alice’s private key. They don’t know it. Therefore they can’t produce a signature and say: “Hi, I’m real, I exist”. And yeah that’s legitimately how you can generate it in a multisig wallet.

So the next question is signing, and this is another slide where you can kind of zone out, it’s only the last bullet point that really matters. I did try to make this accessible despite technically including the math here, so don’t worry if it’s out of your knowledge.

The simplest possible scheme is known as a Scnorr Signature, and it was actually patented for a while… and yeah that’s all. So with a private key, which we’re now calling ‘a’ instead of ‘X’, because no one agrees on letters, no one ever does, you select a nonce ‘r’. This nonce is only is supposed to be randomly generated, it can only be used once. So now you take what you’re signing, that’s generally a message, and you also have to hash your nonce as a public key. And that is something known as the challenge. Finally you calculate the solution, which is the nonce plus the challenge times your private key, and the signature is ‘R’ and ‘s’. I’m not expecting you all to get it the first time but…

Basically because ‘s’ should equals ‘r + ca’, you can multiply both sides times G, because ‘r’ times G is capital ‘R’, which is part of the signature. Then you also have the challenge times the private key, but when you multiply it by ‘G’ it’s actually written out as ‘c’ lowercase ‘AG’. That’s equivalent to ‘c’ uppercase ‘A’, because uppercase ‘A’ is lowercase ‘a’ times ‘G’ are R and A are public key. And then finally you multiply the solution by G, and you can verify this, again to bear with me for one second because this is the important part. Well actually the next level.

So anyone can select a nonce and calculate a signature, because we have the nonce into the challenge, you get a different value and you could get ‘s’ times ‘G’, but you need S, not ‘s’ times ‘G’ making this unforgeable. And the important part is if you know ‘r’, the nonce, you can actually recover the private key. And this is why handling the nonce is extremely difficult it must be done with extreme calc. You also can’t reuse it, as if you reuse it you can do some algebra, a system of equations, and recover it. And here’s where we get back to multisig.

It’s a two-round protocol for producing Schnorr signatures. This means that I send people a message, they send a message back — that’s one round. I do my thing, I send another message, they send a message back — that’s the second round, and I’ll have a signature if all went well.

Everyone selects their own nonce, and they all share the public key of it. And the signature is just a sum of everyone’s nonces. Everyone know the nonce, the signature is all of theirs. Once every participant knows a nonce being used, they calculate the solution for their specific nonce and their specific private key, and then you just add up all the solutions. It’s literally just adding things up. It was written for usage in Bitcoin and was widely planned for adoption.

Then we have insecure multisig. This is the current way we refer to multisig. It was broken. It actually took two years, and it goes to say that writing secure multisignature algorithms is really hard, because it took us two years and this was planned for usage in Bitcoin.

So it was broken into something known as Drijver’s Attack. So this gets into cryptography, where there’s something known as the birthday problem — for ‘n’ people in a room what is the likelihood at least two share a birthday, and 23 people is enough to make it more likely than not. So we likely have a few people here who share our birthday, which sounds insane, you think you need 80 people — no 23. And this can be generalized. Instead of saying what are the odds people here have a birthday, we can say what are the odds a set of hashes will cancel out, what are the chances that they’ll be the same value. Just as I’m asking you: “Do you guys have the same birthday?” I’m asking this hash function: “Hey, do you have the same value?” And this is looking for a collision, where collision is two different values are hash function with the same output.

So Wagner I believe in the 1970s published an efficient algorithm to discover solutions for this class of problems. What Drijer did is prove it was successfully applicable to MuSig. So by having multiple signing sessions run in parallel a malicious signer can cause the group to sign for a message it didn’t even know of. So in just nine concurrent signing sessions is sufficient to enable this attack. We don’t even need 23.

So the exact map for this message, and you are looking for a challenge, that is the sum of ‘n’ other honest challenges. And the thing about these other honest challenges is they’re whatever you’re signing for in a legitimate setting, but when you’re signed for a legitimate setting, the public key is the public key you — can’t touch that the message, everyone has to agree on the message you can’t change that, but the nonce, you contribute part of that so, you do touch part of that, and even the slightest change is enough to calculate a new hash, and that’s all you need to start looking for not one specific nonce which collide or which causes a hash to collide, but a series of nine different hashes which ad is you need them too.

And this actually led to MuSig2. One year after Drijver et. al published their work, MuSig2 was published. Instead of sharing a single nonce, they publish two nonces, R1 and R2, and then there’s now a “binding factor”. We hash all of the nonces with the message being signed. And this is how we calculate the nonces R1 plus R2 times binding factor. And this is important because by hashing the selected the selected nonces into a factor for the actual nonce, a malicious signer can’t manipulate them. If you change the nonce, you then change what it hashes too, and change the actual value being used. And suddenly you have to redo your calculations. And you can’t beat that cycle.

So how does all this relate to Monero? I’ve talked about math, I’ve talked about Schnorr, I’ve talked about Bitcoin, and now I’ve got to mention Monero. The current algorithm used for ring signatures produces multiple Schnorr-like signatures. Because of that all of these concepts, algorithms — they’re all applicable to Monero and they’re exactly usable here. Monero also introduces its own complexities however, as it’s a privacy coin. We like to make things hard for ourselves, that’s why we don’t have payment channels. And one of these complexities is known as the burning bug, which may be my personal crusade at this point.

Every output is theoretically unique public key. And this is known as stealth addresses, one-time keys and so on, and so on. When you spend an input in Monero you can’t just say: “Oh yes, this is the public key I’m spending”, that would say what output is out for privacy. So instead we provide the key image, and the key image is equivalent to that public key, we can do the math just prove it, but we don’t say exactly what the actual public key is. This public key only has one key image, and that protects against double spends.

Even though output keys should be unique, they all have to be, a malicious sender can stop you from having unique output keys. But because they all have the same key image, and the blockchain only allows one key image on the chain, even though they have the same public keys, only one is spendable. Because of that all the other outputs are burned, because the second you spend one, you are spending all of them, even though you only get the funds from one of them. So this was realized years ago, I believe in 2017. It was actually just given to the world on a Reddit comment of all places, and then we’re like: “Oh, we have to deal with this now!” Monero does thankfully handle it properly and has for a while. So this isn’t a concern for any of you.

But now we get into the burning bug and multisig. With Monero’s multisig value, there’s a leader who provides a variety of values, from the Bulletproofs to the output keys, because of all the random data Monero just selects one person to generate all the random data and moves on from there. This leader could reuse an output key however, because they select it. This could burn all the funds in the multisig, because it wouldn’t actually be spendable. Readily secure multisig algorithms.

So how do we prevent these attacks? The general practice is to minimize the amount of data any one participant controls. We also reduce the amount of data sent around, because if a participant can locally create a value, we should let them. I shouldn’t have to trust you that you created a value as XYZ, if I can just do it myself. We’re all here for trustlessness. And then finally if the value must be unique, such as output keys, create it with unique values. In Monero specifically key images can only be used once, so if we hash one into however we generate the output key, we’re guaranteed to get unique output keys, unless someone here manages to break our hash function, which gives us a few other problems.

So for the burning bug multisig fix, output keys were redefined as the output of the hash function, which the leader provides entropy for. So they still select randomness, they still ensure it’s private, but now there’s still a proper hash function including the key images to make sure they’re unique. By having all parties locally generate the actual output keys, it minimizes transmitted data, lowering bandwidth, while also ensuring correctness. The leader’s reduction to entropy means they can’t manipulate it, but the fact they still provide some randomness maintains privacy. And as I said the hash function is seeded with the key images to ensure the output keys are unique.

And this kind of brings us to where are we now, because multisig topic around Monero for a while. It’s been a topic because it’s been insecure for a while. If you’re using multisig right now with Monero, you should not be. We’ve been public about that, and I’m saying it again. We have a PR available, it was actually authored by perfect-daemon and UkoeHB, which implements the binomial nonce scheme, and at one point had a fix for the very above, yet that was moved to another PR. And it’s been subject to extensive review, including one of provided, to ensure we properly fix this — we don’t want to put the community at risk again, because the existing multisig didn’t work and that’s an error. We don’t want to make these mistakes. We’re here to build better financial future with privacy, not find out: “Hey, all your money’s gone!” And thankfully it was only applicable to multisig which is infrequently used, and we’re putting in the review or putting in the work to make sure it doesn’t happen again. So it’s undergoing an audit provided by RINO right now, which I think will have the results back hopefully in a few days at least for the initial version.

And this brings us into the future of multisig, what happens after we fix it. Right now Monero uses a very specific algorithm, which I didn’t cover here, because I think that would take me an hour or two, but it’s optimized for a threshold “n – 1”. This means if you’re doing a “2 out of 3” multisig as you may see in Haveno, or as you may see with group recovery schemes, yeah. Monero uses a custom key generation algorithm for its multisig signing process. But it’s slow for larger use cases. If you want to run a decentralized exchange and you’re like: “Oh, I want 21 out of 30 people to participate in the signature”, this algorithm has a few errors.

So then there’s also FROST. FROST was developed adjacent to MuSig2 and has a lot of the same work. Yet it is “t of n” with a threshold instead of “n of n” requiring everyone to sign it. It still has a 2-round protocol and it’s extremely performant and it’s my current advocacy.

Final comments. Multisig is critical not only as it offering for security, not only as it offering for redundancy, yet also to expand the use cases to Monero, I’m sure. Staff appreciate layer two, I appreciate decentralized exchanges, we have the Farcaster team is going to appreciate atomic swaps, and multisig is the top for that. Also I actually have a FROST-based multisig library for Monero, I published it shortly before the talk. If anyone wants to check out the GitHub for that, see what’s up, I’m happy to share it. But don’t use it. It’s not even been reviewed. I’ve had a private review a few months now. Please don’t use it. I’m not responsible. But if you are a Rust developer interested in such work, reach out, as I would love to hire you.

Any questions, if we have time? I’m not sure how long it’s time.

_**Audience:**_ I’m sure this is a dumb question, but if the leader in a multisig round is running malicious code, they still can’t exploit the burning mode crowd.

_**Luke:**_ With the burning bug fix it removes their ability. Originally they just provided the output keys directly, but now that’s a hash function using the key images. As much as the leader may be malicious they can’t change Monero’s double spend policy, and they can’t change the key images for the keys they have, and that will force them, that will make them unable to generate such keys.

_**Audience:**_ Awesome, thanks.

_**Luke:**_ Thank you
