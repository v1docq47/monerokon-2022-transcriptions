# Justin Berman

_**Justin Berman - Seraphis/Jamtis: Feature overview of the proposed upgrade to Monero**_

_Monero Konferenco  #MoneroKon2022 Day 2_

[https://youtu.be/xGEBRQU1lzw](https://youtu.be/xGEBRQU1lzw)

---

So I’m going to be talking about Seraphis and Jamtis today, the current updates to core features in Monero, and the idea of this presentation is to give a high level overview of the changes that would impact users and what users should expect or would expect from what these upgrades would bring from a pretty high level. So it’s not going to get too deep into the weeds of the technical issues, I’m going to try and stay to the level above what of that. So and this is also the same presentation I gave at Monerokon, but re-giving it just to have the slides alongside the presentation as well, and hopefully it could be a clear as we go through this.

So the background and basic impetus for Seraphis and how it came to be. So there’s the way Monero works. The one of its core privacy properties, the way one of the three pillars of its privacy properties is called “ring signatures”. So ring signatures are used to provide sender privacy. So when I go and send somebody else some Monero, the way ring signatures work to ensure that my transaction can’t be linked or traced back to another transaction, is that I will construct a ring signature which pulls from other transactions from across the blockchain that have happened in the past and references a set number of those today, that number is 16, well 15 others in each input to a transaction, so that is essentially one of major, core features to provide sender level privacy, and so there’s been continued research into how to increase that number from 16 to something potentially much larger, and with still maintaining a level of scalability and efficiency that is acceptable.

So Triptych was one aspect of research or one research avenue that was taken back and started, began back in 2020 and 2021, and it found that we could support larger ring sizes, but unfortunately the implementation would end up with a multisig user experience that wasn’t so great. So that effort kind of subsided and died down.

Now Lelantus Spark was another back in 2021, that Firo is pushing forward at this point, where you get nice properties of large ring sizes and nice multisig.

Seraphis was developed basically by a core Monero researcher, that also supports larger ring sizes, nice multisig and has a new modular transaction protocol that’s specifically built for Monero and also offers a host of new features that we’ll get into later.

And then Jamtis came along, a bit after Seraphis by tevador, who also has implemented stuff for RandomX and Polyseed in the past different Monero features. And so Jamtis is a set of well thought out upgrades to Monero’s core features that can be supported alongside Seraphis and we’ll get into those later as well.

So here’s an overview of the things that I’m going to discuss. These eight things are not everything that are proposed in Seraphis and Jamtis. These are a slice of what I feel, what I personally picked as some of the biggest changes or the most important ones to highlight. But they’re still more that are discussed, and this is just my own personal bias of which I felt were strongest to get into. So I’m gonna go into these one by one.

So to start — the view balance key. So this is a private key that you could use to see all incoming as well as outgoing funds. So today in Monero we have a view key and a spend key. The view key is only able today to see all incoming funds, but is not able to cryptographically determine outgoing funds. For that you need the spend key, which is also used to spend your money.

So the pros of having a view balance key. Now it enables a fully featured and safer watch-only wallet. So today if you want to have a wallet that can only see funds and not spend, what you have to do to use that watch-only wallet is continuously move to a signing device that has the spend key on it, generate key images on your spend-wallet. So basically you have to load your spend key into memory somewhere and use it in order to have your fully featured watch-only wallet that is able to calculate your balance and is able to see outgoing funds. So basically that’s a bit of a safety concern anytime you have to load your spend key somewhere — that’s an attack surface that opens up. So a view balance key is something that enables you to have this watch-only wallet that doesn’t require a spend key to use anywhere at all for the watch-only wallet to be able to calculate your balance and function fully featured.

Now a view balance key also will improve all of the signing experiences where there are multiple signing devices that includes offline cold signing, where you might have your watch-only wallet somewhere, and then you’re an offline device where you use to set sign your transactions — it includes a hardware wallet, which is your signing device as well, and it includes a multisig wallet, where you have multiple participants, who could be signing from different locations of different wallets. So the way that a view balance key will improve the experience for each of these is that, again this caveat where each device, each signing device needs to be sending these key images across the device.

So for example you’re one participant in a multisig, you’re one of three, and you need to know which funds have already been spent in the multisig wallet, and you need to know what your balance is. So the multisig experience today functions where you have to do rounds of communication with the all other multisig participants, where you’re sharing information, the key images, that allows you to determine what the outgoing funds are and what your balance is, what outputs are allowed to be signed and how to construct transactions in the future. Essentially that you require these continuous rounds of communication that can be done away with a view balance key, so that each user knows what has been spent in the wallet without additional communication. So the same goes for your offline wallet, so your signing experience there and a hardware wallet has to exchange less information between device and machine where your wallet is located. So this experience gets improved by the existence of the balance key.

Now one controversial aspect with this view balance key is that there is now this additional key that if given up has more cryptographic information about your Monero transaction history, which is a concern — people have expressed concern over this.

Now I’ll get more in the cons, but it’s important to recognize that today with today’s view key it already is possible to determine and make very-very strong educated guesses as to what outgoing funds are a users’. You can’t make cryptographic dresses with cryptographic certainty, so it’s not like we can design watch-only wallets that are fully featured, that are have the perfect user experience, that are making these guesses. But someone doing surveillance or someone who has access to a view key it can make very-very strong guesses as to what funds are spent by the user, just with today’s view key. So that’s something important to note and to keep in mind when thinking of the privacy properties of the view balance key, and what it would enable beyond today’s view key.

And then, finally, I’ll get into a light wallets with stronger privacy properties, and this is just a separate detail that is also a mitigating factor of collecting view keys and all that. We’ll get into this later on.

So the cons of a view balance key — getting into this a bit deeper. So once ring size is due and after ring size is due already increase a significant amount. So this is in some future hypothetical, provided the update of Seraphis goes through, once this occurs, and once we do have larger ring sizes, then you could argue that a view balance key at that point can be a more powerful surveillance tool than a view key that can only see incoming funds. Because then at that point guessing making very-very strong educated correct guesses as to what a user’s balance is, as to what their outgoing funds are, becomes more difficult to do. So at that point, then you could say the view balance key is worse than a view key now.

There are two potential outcomes that could arise, that are the highly negatives of what the view balance key enabled, I would say. First is let’s say powers that be mandate sharing view balance keys or to use an exchange you have to share your view balance key, or to use this regulated service you have to share your view balance key. Now that is a concern, something to be concerned about for sure, but it should also be kept in mind that could already be that avenue is already available today, where users can already be compelled to give up their view key today as well as all their signed key images which then show what their outgoing funds are, so what a user’s outgoing funds already are completely with cryptographic certainty. So essentially if we say that the powers that people start requiring giving up view balance keys, there’s not much reason to think that they wouldn’t also do the same for users today having to give a view keys inside community key images today which they don’t. So it’s just something to keep in mind of the view balance keys do certainly enable greater power and to that level that is something to be concerned about it’s tough to say.

And then the second outcome — there is a centralized wallet service that may collect these view balance keys so that users get instant wallet loading. Now that is another thing that is mitigated, that I’ll talk about in the next section that hopefully there’s this will be this new tier, that’s Seraphis and Jamtis offer, where decentralized wallet surface will be able to offer instant wallet loading without necessary without needing to get the view balance keys. So get into that next as well.

So light wallets with stronger privacy are also enabled by Jamtis. So in Monero in order to determine which transactions belong to you, your wallet has to scan the entire blockchain from the last time it was opened to try and decrypt every single transaction to see which ones are yours and which transactions received to you and spent by you in the chain. And so if you haven’t used your wallet in a while, this can be pretty slow. It just depends on how the last time you use your wallet.

So what light wallets do is they offload the scanning to a separate device. So what you could do is you have your phone that functions as a light wallet, a light mobile wallet, and then at your home you could be running alongside your node, a server, it’s called a light wallet server, that’s continuously scanning the chain for your transactions. And so that when you open up your light wallet it will point to your server at home that is continuously scanning the chain, and will instantly load, and you’ll be able to instantly use the device and spend without having to wait for it to scan the chain.

So there are some open source implementations of the light wallet server, monero-lws is one by vtnerd, and then openmonero by moneroexamples is another. And essentially the way light wallets work is they have your view key on them. They store view key on their device, and so it uses that to identify all of the received outputs, all the transactions where the user received Monero, and it can also see the amounts in those transactions.

So the proposed upgrade for light wallets is that you can have a server that one can’t tell any amounts that are received in the transactions or spent, and can’t definitively identify which outputs are user’s. And in Seraphis the terminology is the proposed terminology for outputs is “enotes”, and that’s what we’ve been using to describe them. So basically so long as a user doesn’t reuse an address to receive Monero, the server isn’t able to tell — so there’s this caveat in the light wallet here, where the server is able to identify received outputs only if the user doesn’t reuse an address. So this is still a work in progress to mention, and so more feedback along is definitely appreciated and warranted, and we would like to get more people chiming in on this tier as well.

So getting deeper into the pros and cons. So again the idea is that with this light wallet server you’ll get the same exact user experience of instant wallet loading, instant usage, as soon as you open your mobile wallet or your phone, you’re ready to go with that gain in privacy where the server can’t tell anything or can’t tell the amounts and received outputs definitively. So this also poses the threat that a large centralized light wallet server could pose to the anonymity set. So for example today we have mymonero, which is hosting a server, which has access to a number of users view keys, which can see and identify transactions that belong to the user and make guesses as to their spends. Now the way Monero works is that we have a large anonymity set, where when I construct a transaction I’m referencing other people’s transactions from across the chain in constructing my ring signature to ensure that nobody looking at my transaction can be able to tell which one is the one, which Monero I’m spending in my transaction. Now if there was some huge party that knows a huge, a large percentage of the spends that have occurred on chain, and can build this graph of this transaction links to this one, and so if this person tries to reference this other one, we can eliminate it, and we know that that’s not the case. So essentially that’s it reduces the anonymity set, when you have a large party that knows which spends and receives belong to users.

So if we can create a light wallet server, where the light wallet server has limited visibility into how users are spending, and has limited information, less information to be able to definitively tell what linkages there are among users and among transactions, that reduces that light wallet server’s capacity to reduce the size of the anonymity set. So there’s another con here with this tier. And then finally I’m personally extremely very-very excited about this tier, because I like this idea of being able to run this light wallet server at home not just for me but for family and friends as well, to where you can have this model of the “Uncle Jim”. So credits to a Diverter on Twitter, if you gave a presentation at Guns N Bitcoin and brought this up. So the idea with Uncle Jim is that you have somebody within your community, someone within your close-knit group who is running the infrastructure, who has the technical knowledge to be able to host a node, host a server alongside that node, and run it. And then the people close to that person, close to the Uncle Jim can just point their wallets to that server. So this idea I think is a powerful one to our towards scaling, the decentralization and of Monero essentially. And I think that that is an avenue towards getting like the optimal UX into the most people’s hands.

So now the cons with this light wallet tier. So first off all, that I mentioned earlier, if a user reuses an address, they are revealing to the server which enotes belong to or received to that address. So it’s a pretty significant con, because I mean one of Monero’s core privacy properties, one of its pillars is this thing called the “stealth address”, where I can put my stealth address anywhere in the internet, and I can accept donations to it, for example, and if I receive any transaction anytime someone sends Monero to that stealth address, nobody can tell on chain that I’m the one receiving that Monero. So that’s the a huge benefit of stealth addresses that is pretty much done away with this light wallet here, because the light wallet server is then able to tell now. It doesn’t go on chain, it’s revealing that information to the light wallet server.

And then there’s also another pretty very significant caveat which is that time analysis — it is likely able to make good guesses as to the spends and receipts now. Not definitive guesses, but it’s probably the case that a server that is keeping track of all interactions to and from the server with all users, and collecting all the information on people accessing the server, will be able to still make guesses as to linkages between transactions. Now they won’t be perfect, they won’t be cryptographically certain, but the guesses are still plausible, which is why I would still recommend very strongly that you run your own light wallet server if you’re technically capable. And that’s still be the ideal to have everybody running their own and everybody running their own node, but this is just an extra caveat to keep in mind with this tier.

And then final con is that if you receive two plus enotes in a transaction, it also enables the server to easily identify that those enotes belong to the user. And there are possible ways around this and to mitigate this downside and possibly eliminate it, but it’s something to keep in mind, especially with another idea that is on the table and something in consideration, where you could have transactions where users receive many enotes in a single transaction, or today outputs in a transaction, so that they’re easily able to spend them, even if they have a small transaction in the future. So get it into this little UX pinpoint of Monero. So when I receive some Monero, I have to wait 10 blocks in order to spend that Monero. Let’s say I only received one Monero in my wallet, I then go and spend it in the future, I have to wait these 10 blocks. Now let’s say I had divided receipt of this one Monero into multiple enotes or outputs into 16, for example, which is a feature some wallets currently support, it’s called “pocket change”, I believe, Cake Wallet as well supports the feature, so essentially this would enable me to spend some of the enotes and then keep the others available for spending. So this caveat within the light wallet tier would essentially offer a disadvantage for users, because the server is still able to tell that those now enotes belong to the user. So just something to keep in mind with this tier as well.

So another thing to discuss, third point — new addresses. So because the move is towards larger rings, just there is no way to images, there’s essentially no path forward that will enable us to upgrade without migrating to new addresses. Now what this means for users.

So no users would need to create a new seed — all old seeds, existing seeds would work completely fine. So that’s just one thing to start. Funds received in the past to any old address would always be spendable. So any Monero received in the past is completely spendable without any concern. The only change, the biggest change is that any fund sent in the future after the upgrade would need to be sent to a completely new address. So that’s the fundamental expectation that users should expect.

And so this isn’t completely settled yet, addresses are not set in stone completely. There’s still a few things that are being hashed out and discussed. That would impact how exactly the addresses would look like. But this is the general gist of what they look like. So on the left you have the old address scheme, which you can see, is basically you have some capital letters in there, and then on the right you have a much longer address. It includes an additional public key, and it’s also in base-32, which is all lowercase as you can see — easier to read and easier to copy. Size wise that’s about the general size difference, not the exact, but that’s about what to expect in the new address compared to the old.

So Seraphis now, because we would have to move to new addresses as part of this upgrade. It presents this unique opportunity, where we can create a new address scheme that takes all this feedback that users have expressed over the years, and pinpoints that users have experienced and complained about, and tried to design an address scheme that’s robust, that basically sympathize and solves all those issues that people have experienced in the past. And so Jamtis is essentially seizing this opportunity. And that was the idea driving tevador towards a lot of the upgrades, and most of the upgrades that are proposed in Jamtis.

So first of all there’s a simplified address scheme. So today in Monero they’re three main address types — you have your standard address, the one that starts with a 4, that is the default wallet address, and then there are subaddresses, and subaddresses basically allow you to have one wallet, where you could dish out new subaddresses to different counterparties. So let’s say you go to merchant or you want to receive or withdraw from an exchange, and you don’t want to link the address that you’ve received from the exchange to some other party, who’s also going to send you some Monero. So you would generate a new subaddress and so that subaddress can’t be tied to the other, and you could just use one wallet to house these different addresses. That’s the essential idea behind subaddresses. And then we have integrated addresses, where you have an address and then concatenated with a payment ID at the end of it. And what this enables is merchants to embed these unique payment identifiers at the end of an address to handle order fulfillment, to tie to the payment to a particular order, while also having a single address that’s pre-pended in front of the payment ID that users can trust, that they’re sending to the same exact merchant that they had been using in the past.

So what Jamtis proposes is limiting the difference between standard and subaddresses in favor of single Jamtis address, and then replacing integrated addresses, with which have a whole set of problems, that I’ll discuss later on, with “certified” addresses, and we’ll get into these in a bit.

So problems today with subaddresses. So first, which is probably the most significant, is that it’s vulnerable to an attack called the Janus attack. And what that attack enables is someone, who might know, that you might not have a suspicion, that you own a particular subaddress, if they’re sending you some Monero in the future, they can construct the transaction in a way, where if you confirm receipt of that Monero you would be giving up the information that you own a particular subaddress without knowing that you just gave up that information. So it’s a pretty significant attack on subaddresses that is undetectable. That is a an issue that would be patched and fixed with this upgrade.

So other issues with subaddresses. Generating subaddresses requires keeping track of the ones already provisioned. And this is also related to this next point of recovering funds received to subaddresses automatically is not robust. So essentially the way subaddresses work today is that you have to increment like, let’s say you want to receive to your first subaddress, that subaddress zero, your second subaddress that subaddress one, your third sub address is subaddress two, so you’re incrementing in that way to generate new subaddresses. Now that means that let’s say you have one device that has generated some of the subaddress over here for the other one, if the other one doesn’t know that’s been generated — you have another wallet and another machine — there’s no communication across the devices by default that makes sure that they’ve already provisioned which is an issue. And so you have to be keeping track of which ones you’ve already given out, so that you don’t end up reusing one.

Now there’s also this issue that recovering them is not automatically robust, because we can’t exactly tell, let’s say a user generates 3 000 subaddresses, and then generates a subaddresses that like really far out, let’s say they just randomly decide to generate a subaddress at 5 000, like the index number 5 000. The way the wallet recovers funds sent to subaddress today is what’s called the “look ahead”, it’ll look at the first thousands of subaddresses that have been generated, and it generates those thousands, and if there is one subaddress which has received Monero outside of that range, then the wallet isn’t by default able to detect that funds are received to that subaddress. And users have run into issues, where they weren’t able to recover funds sent to the subaddress, and so that’s just been an issue that people have experienced and run into.

Now there are transactions — another caveat, an issue with subaddresses is that when you have a transaction that has three plus outputs, and it uses subaddresses, that’s identifiable as such on chain, meaning that you can tell that this user used subaddresses in this transaction, because they’re three plus outputs, and so because there were three plus outputs and because the way subaddresses work, you could then see information on chain that gives up that: “Ok subaddresses were used in that transaction”.

And then finally they take extra development to support, and they increase the complexity of the protocol. And there are some wallets today that still don’t implement subaddresses just because of this extra development that they take to support.

So we’ve got some more. So generally the best practice is to use a new subaddress with every counterparty, meaning that if you’re receiving Monero from different people, you don’t want to be giving up that you own one address, and you don’t want to be giving up information to counterparties, who can collude to then see: “Ok, this person received to this address. We know these two transactions belong to them, because they use the same address for both of those”. Now even though the information doesn’t go on chain because of stealth addresses and how Monero works, that information is still a bit of a privacy, something that you’re giving up by not using subaddresses across different counterparties.

And now I’d say that I also say the existence of the standard address, which is like the default generated primary address, detract from this, because it’s in some way tacit encouragement to use that primary address and to use the standard address that your wallet loads with. Additionally, let’s say you’re using a standard address across two different wallets — you have generated two different wallets — and you give out the standard address to two different people, two different ones, they would both be able to tell you’re using a different wallet, and you’ve created a new wallet, which is a bit of metadata there’s not a whole lot someone can do with that information, but it’s just something that you’re giving up, because the standard address is identifiable to one wallet — there’s only one per wallet.

And then there’s just this general choice that it places on users of “Should I use a subaddress? Should I stick with a standard? I don’t know!” And here’s a relevant XKCD, where you have one person saying: “There! If we steal one of those cars, we can get to the base and diffuse the bomb! The one on the left accelerates faster, but has a lower top speed. Ooh, the right one has good traction control. Are the roads wet?” And then protip: “If you ever need to defeat me, just give me two very similar options and unlimited internet access”. Now this choice to use a subaddress versus standard address — they’re still pretty similar options, and it’s just a thing that’s thrust onto a user to think and decide: “Should I be using the subaddress here? Should I be using the standard? What should I be doing in this circumstance?” And it’s just an extra UX thing that really shouldn’t need to be there.

So the idea with Jamtis is to have a single primary address, I mean a single method of generating addresses that each one is not distinguishable from the other. So there’s no more idea of this one primary standard address, there’s just basically Jamtis addresses. And another huge benefit that is you’d be able to generate this Jamtis addresses randomly and offline. And so these address indexes as part of the Jamtis proposal is to use 16 byte address indexes, which would support UUIDs as well for merchant systems that want to use them. But essentially it has enough bit space to support random address generation so that cross devices and cross wallets there needs to be no keeping track of which one was generated on that incremented step. So it’s just each wallet can randomly generate it and it’s good to go, good to use that address. And there’s also no need for a lookahead, where you have the wallet to generate this thousands number of subaddresses and then keep them in memory, and check which funds receive and belong, were received to this range of subaddresses, rather than needing to keep that lookahead which has resulted in users who might have funds and receive Monero two subaddresses farther out of that range, losing or not seeing that those are recoverable. Essentially in Jamtis you could simply decrypt which address received which Monero in real time right on the spot. So there’s no lookahead — you’ll know exactly which one received, which address received which transaction.

And then they made it Jamtis addresses also mitigate the Janus attack which is just a vulnerability currently presence and subaddresses, as mentioned earlier. And then finally the single fact that there’s just this single Jamtis address type should mean that it’s easier to develop for. Once a wallet supports the Jamtis address it’s done and there’s no need for extra support to ensure that the wallet is supporting addresses in the same way as other wallets. That’s the basic premise idea.

Certified addresses. So again, today there’s this idea of the integrated address, and those are useful for merchants who want unique payment identifiers for each order. When you’re selling a particular good, you generate a unique payment ID, tack it on to the address, and tack it onto the static address that for repeat customers can look to and see.

Now there’s problems with integrated addresses today. First is you can’t send to more than one integrated address in a single transaction — it’s not possible. So if you want to send to multiple parties or multiple integrated addresses, you’re out of luck. You’d have to create multiple transactions, which is just a pain to deal with. And you also have this thing where all transactions have an eight byte payment identifier on chain, which is just an extra eight bytes that all transactions now support with dummy payment identifiers, which is just a bloat that doesn’t necessarily need to be there. And then you can go and also read this proposal that covers these downsides at this link here. There’s a basically a pretty big push to deprecate integrated addresses because of these issues.

Now certified addresses are a solution — they’re unique, they able to enable you to generate unique generated addresses, unique Jamtis addresses, so that same that same single type of Jamtis address that are then signed by a single private key. They’re just digitally signed as Jamtis addresses essentially. And then what users can do is they add a merchants RID, the recipient identifier, to an address book, where they’ll know for sure that once they have added this merchants, essentially once they’ve added the merchant’s fingerprint, they’ll know that any payment sent to the merchant in the future that comes from that’s signed by the certified address, comes signed with that exact key that they have in their address book. They’ll know for certain that they’re sending to the to the correct address, and there’s no risk of some sort of man in the middle attack, where stealth address can be modified or changed in any way, get signed by a known address.

So getting into this notion of recipient identifiers. So there’s just this general problem of copy pasting and then visually looking at an address to see: “Oh, are these characters exactly correct?” It’s a nerve rack, it could be a nerve-wracking process that it’s just not particularly enjoyable. And larger addresses will make that a bit worse. So the solution there is this thing called “recipient identifier”, where you take a hash of the larger address, and you get this the string here in orange, that’s a lot smaller, easier to compare. And so what the users would be expected to do is they see on their wallet that recipient identifier at the bottom matches up with what’s displayed in the merchant interface on the point of sale system. And that’s the idea with recipient identifiers.

The generate address key. So today there are some problems with generating addresses. So let’s say you have a merchant system that wants to generate new addresses and accept funds to new addresses. What that requires is a server somewhere that has access to a user’s private view key, and that key is able to see all in incoming received funds. Now also another additional problem is that integrated addresses, while integrated addresses don’t need the private view key, they have their own set of problems, which were mentioned earlier. So the solution here with Jamtis is a new generate address key that’s specifically made that all it could do is generate Jamtis addresses, and that’s it’s just one key purpose built for that — you can have a system that only houses this key that’s there just to generate new addresses, that doesn’t need any other additional info, any other private view key or anything like that.

Now transaction chaining is another key feature of Seraphis. So some problems today that transaction chaining solves. So it’s currently impossible to pre-sign a transaction, meaning that let’s say I want to construct a transaction today that spends from a transaction. So I wanted to construct a transaction A, and then I want to construct the transaction B that spends from transaction A, so spends the Monero that is sent in transaction A. And I want to do this and construct both at the same time before submitting them to the blockchain. So that’s just impossible to do today. And without this feature atomic swaps only work where Bitcoin or Ethereum move first in the transaction. And it’s just the way the atomic swap protocol currently works, and it’s just one limitation and hurdle to get over — that’s tricky. And what transaction chaining enables is this feature that’s exactly needed to enable Bitcoin to move first so. That’s one like pre-core feature of Seraphis that is enabled, especially by the modular transaction protocol that would be nice.

And then also there was a question when I gave the presentation on Monero Conf from articmine regarding transaction chaining and if it would enable something similar to Bitcoin’s “Child Pays for Parents”, and it’s not exactly the case. Their caveats with “Child Pays for Parents” that aren’t exactly solved by transaction chaining. So I just wanted to clarify that, because I think I gave an answer that wasn’t exactly perfect towards that. So just clarifying that information.

So thank you for listening, if anyone who’s made it this far. And again, so feedback is definitely encouraged — welcome, especially merchants, anyone who’s using Moneroi. Any UX pain points or things that are identified in Jamtis and Seraphis, that are some things that you like or don’t like. That feedback is more than welcome. Here are a couple links and Matrix channels. And I haven’t updated this presentation, but there are some more links that I’d like to share and include. There is a No Wallet Left Behind Matrix channel that I’m going to throw. So wherever this presentation is posted, we’ll include a link to that. And then as well as a repository where that is housing the effort towards the migration, and that is basically detailing tons of issues that are coming to light. And that effort is being coordinated by Renee Brunner, so that’s another place to go look to in and see, how the development is flowing on this front. So we’ll include, make sure to include those links wherever this is shared. No questions. Thank you for listening.
