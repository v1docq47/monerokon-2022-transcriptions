# koe

_**koe - Seraphis Balance Recovery**_

_Monero Konferenco  #MoneroKon2022 Day 2_

[https://youtu.be/fEJpE7LumG8](https://youtu.be/fEJpE7LumG8)

---

_**koe:**_ Hello, everyone. I’m here to talk to you about balance recovery in the Seraphis protocol.

So, Part 1 — The warm-up. What is the transaction protocol and what is the enote paradigm? So an enote is just an amount that is owned by someone. In Bitcoin and in the past, and most of the time these are called outputs or transaction outputs. A transaction on a blockchain is just an event that consumes enotes and creates new enotes. So the amounts and the enotes are consumed and transferred into new enotes, who have new owners. And the blockchain is just a series of transactions transferring funds between users.

When we’re talking about balance recovery, users want to know what is the total amount that they can currently spend. So they need to identify new enotes that appear in the ledger, that are owned by them, and also locate where or if any of the enotes that they’ve received in the past have been spent. The balance is simply the amount recorded in enotes that have not been spent yet, that they own.

When we’re actually thinking about how do we design enotes and also hidden from different tiers, like wallet tiers, so there could be like different tiers or ability to read information in the enote. A third goal that hasn’t really been thought of too much in the past is the “principle of least astonishment”. So when you discover an enote that you own in the ledger, there should not be nothing surprising about that enote — the fact that you own it, and which address owns it. You shouldn’t find that enote and then be astonished to discover that it’s unspendable due to a previous enote that you received, stuff like that.

We’re going to be talking about a lot of cryptography today, so here’s some notation. We have elliptic curve points, we have scalars, we have operations, we have generators, and we have hash functions. The one hash function to really note here is the keyed hash, which we don’t have with Cryptonote. So with Jamtis we add this keyed hash in Seraphis for very explicit ways of hashing things with a well-defined secret key.

So let’s recap how Cryptonote and RingCT works. We have subaddresses, so this is like the frontier of Cryptonote is subaddresses, we have the private view key, the private spend key, and when we’re making an address. We include a subaddress index. This way a user, who has these two private keys, view and spend key, can generate many-many subaddresses from those keys. And funds received to any of those subaddresses can be discovered with the same private keys. So this improves the privacy attributes of the subaddress system by allowing users to send out different addresses to different people, and then those people, if they talk to each other, they won’t necessarily know that the addresses are from the same person.

So in practice we do this by extending the spend key with a subaddress index, with a modifier, that’s a hash of the view key and the index. So we have two public keys in the address itself, that’s sent out to other people. We have the spend key so-called, which is actually a Diffie-Hellman base key, so it’s used as a Diffie-Hellman base key as we’ll see, and then we also have the view key, which is the Diffie-Hellman pubkey that will play a big role in balance recovery as we go forward. So the important thing just to note here is how the private view key is itself a Diffie-Hellman exchange with the spend key, just directly with the view key itself without any address index modifier.

So when we construct a Cryptonote or RingCT enote, this is the entire process here. So we’re given an address, an amount, an optional payment ID, and the output index of this enote within the transaction where it’s going to be placed. So we begin by creating an ephemeral pubkey between an ephemeral key and the recipients of spend pubkey, and then we also create — so this is normally you you’d see an ephemeral key that looks like r_t times the generator G, but in our case we’re making the public key multiplied by a user defined Diffie-Hellman base pubkey as the user spend key. And the important thing with this is it allows the Diffie-Hellman base key to be a function of the subaddress index. So you can generate many — well we’ll get to that.

So then the Diffie-Hellman derivation — this is the normal Diffie-Hellman thing that you usually see. So we have the ephemeral key times the actual user Diffie-Hellman key, which is the view key in this case. And then we hash that to get the secret of the sender-receiver relationship. And then we use this, the sender-receiver secret, to finish constructing the enote.

So we have an amount which is a Pedersen commitment between the secret and the amount, the amount masked by the secret, we have the amount itself encoded by the secret for the recipient to later decrypt or decode or whatever, we have the one-time address, which represents ownership of the enote, so you have to sign with this address to prove ownership of the enote, when you’re going to spend it. We do this by simply extending the user’s spend key with the sender-receiver secret. A recent addition is the view tag, which as we’ll see speeds up the balance recovery process at the cost of only one byte. And we also have the payment ID, which is just like an eight byte string and encrypted with the sender-receiver secret… oh, sorry, just the Diffie-Hellman derivation — we save a hash by just directly putting the derivation in there. And right now only one encrypted payment ID per transaction is allowed, so only one recipient can use the payment ID. So the final enote is the address, the commitment, the encrypted amount, view tag, and the optional encrypted payment ID, and then plus the ephemeral base or the ephemeral pubkey, which will be used for balance recovery.

So here’s the Cryptonote key image. It’s a bit hard to read, but here we’ll go through it. So we have the key image which equals… so these are all, this is the private key that’s attached to the one-time address. So we have sender-receiver secret here, I think I’m missing a hash in there, but we have the sender-receiver secret, which is a based on the Diffie-Hellman derivation, we have the output index itself, then we have the subaddress extension, and the spend key. So all this information, kind of each chunk of the key has different functions. So we have the spend key which is the like the core ownership mechanism for the enote, so you must have the spend key in order to sign on a key image and also on the one-time address. Then we have the index extension, which is used to make sure that all your subaddresses are separated from each other and have no distinguishable relationship. Then we have the sender-receiver extension or secret extension, which hides the static subaddress spend key from observers. So to create a key image you need all of these private keys, because these are all multiplied by hash to point of the one-time address. So you have this like interdependency between the key image and the one one-time address. That means you have to have all of these pieces in order to create the key image.

All right. So now we get into balance recovery. So view scanning is the part you can do with just the private view key and knowing the address’ public spend key here as we can see. So the first thing you have to do is pre-generate all this spend keys that you’ve for subaddresses you think might own funds for your wallet. So this is the case when we’re given some scanning up here at the top, scan info. So we have an enote with all of the enote info, we have the ephemeral key, and we have the outputs index in the transaction. So we pre-generate all the keys that might own this enote, we create a Diffie-Hellman derivation with the ephemeral key stored in the transaction, so we multiply the ephemeral key by our private view key to get the derivation, we compute the view tag as a simple hash directly of the Diffie-Hellman derivation. If the view tag doesn’t match, then we immediately abort. So this is an efficiency improvement that should be go live in the next hard fork. The view tag is one byte. So only one out of every 256 outputs on the blockchain that are not owned by you will fall through this trap here. So the reason we add this is because the following operations are quite expensive. So if we can skip those for a lot of out outputs that we don’t own, then we can save some time during scanning.

So the next step, we would take a hash of the Diffie-Hellman derivation together with a secret, and then we test the one-time address stored in the enote to see if it matches one of our pre-generated subaddress spend keys. If it’s not in the pre-generated list, then we abort. So this is a violation of the principle of lease astonishment, because we might own this enote, and it just so happens that the subaddress spend key that owns it is not in the pre-generated list. This impacts some users, not most users, but a few users, but it’s kind of a small annoyance, and it would be better if we didn’t have that annoyance, I guess. You could also decrypt the payment ID, I think you ignore it if it’s null.

Part two — amount recovery. So at this point, probably, if we’ve passed the subaddress spend key test, then pretty much all the time we all in, but just in case we decrypt the amount and recompute the amount commitment just to make sure that it’s not malformed. And the result is our enote that is owned. We do not have the key image at this point, because the key image requires the spend key, the private spend key. So that’s view scanning with Cryptonote.

So now we can move on to Seraphis balance recovery. In a lot of ways what I’m going to be talking about from now on is similar to Cryptonote. There are a few critical differences. So one critical difference is the construction of the one-time address in a Seraphis enote. So before the one-time address was some key times the generator G, now we have two generators X and U. And then we have two private keys within the one-time address. And then the amount commitments are the same as in RingCT as well as the encoded amount. When we’re going to spend an enote, we make some more changes as well. So we make a representation of the enote we’re spending. So a mask of the one-time address, masked version of the one-time address, and the amount commitment — those two are not the subject of this talk. The key image however is an important thing to look at. So the key image construction in Seraphis is the U from one-time address, the U key divided by the X key times U. So this construction will be important to talk more about later.

So an outline of balance recovery, as usual we try to reproduce the one-time address — we decode the amount, we try to reproduce the amount commitment, and then now we have this added step of computing the key image and storing it for later. So this whole first recover owned step can be done with the main view key that we’re going to talk about. And then after this recover owned step you can identify spend keys by simply looking at all the enotes in the ledger and matching key images against the locally stored key images, which were generated by the view key. So all of this can be done, this whole page can be done with just the view key, that we’ll talk about.

So in practice we use the Jamtis addressing scheme to implement all this stuff here. So all these this is kind of not well defined, but with Jamtis it’ll become well defined. I want to be clear from the start that the most of what is in Jamtis could be applied to Cryptonote and RingCT with a few small things that are geared for the Seraphis construction of one-time addresses and key images.

So here’s the key structure for Jamtis. It’s a little more complicated, but having these extra keys gives us more fine grained control over the information access during the balance recovery process. So we have the master key which is equivalent to the private spend key, and then we have the view balance key —these two keys are the main keys — and then we have some derived keys: we have a generate-address secret, which spawns a cipher-tag secret, we have a find-received key, and we have an unlock-amounts key. I’ll note that the unlock-amounts key was just added two days ago, but I think it’s important.

So these are the wallet tiers you get with all these different keys combined. So we get the master key, with the fully powered wallet we have the view all wallet tier, we have the view received wallet tier, which can only view incoming enotes that are not self sends which we’ll get into later, you have the find received key, which is a pre-processed scanning of the chain, and we have the generate address tier, which can only make addresses for your account. And I think Justin is going to be talking about this more later, about these tiers and how they impact users.

All right. So we here we have Jamtis addresses. So the Jamtis addresses are really kind of a compact — they contain all of the information access tiers in a very compact form. So it’ll take a little while to unpack, but we’ll get there. So first note, so we’re doing away with the subaddress terminology, and we’re just talking about addresses now. Just for simplicity I guess. So we have the address index modifiers, which are basically the same thing as subaddress modifiers — they allow us to have many addresses with the same base key structure or of the same user keys. So we’re gonna be extending our address keys with the index modifiers.

So here we have our address contents. So in Jamtis we have three public keys instead of two and the reason for this is to give us more fine grain control over information access. But the thing to note here is that the spend key is no longer the Diffie-Hellman base key of the user. Instead we separate that out into a third key, which is a function of the index modifier and the unlock-amounts key. As we’ll see we’re going to be using a reverse Diffie-Hellman as I call it I guess to control amount information access. So again we can start by looking at the Diffie-Hellman base pubkey, we have the as I said the index modifier and the unlock-amounts key and then the Diffie-Hellman pubkey of the user, the find-received key is basically Diffie-Hellman with the base key using our find-received key. So the only difference is the added find-received key. And so this is very similar to the Cryptonote address view key, which is the private view key multiplied by the spend key. So in this case we have the find-received key multiplied by the base pubkey here. We also have the spend key which is we have the master key times U, we have the view balance key, so the core, the most central view key times X, and then an additional address index modifier or the spend key extension up here. So we have two extensions or two modifiers. The spend key extension goes on the spend key, and the address privkey goes on the Diffie-Hellman stuff.

So the fourth piece of an address is this address index tag, so this has an important role throughout the balance recovery process. So the address index tag is simply you cipher the address index with a small MAC, and then store that with the address. So right now I have implemented a 16 byte address index with a two byte MAC. And the reason for such a large index tag, so 18 bytes, is with a 16 byte address index you can reliably and confidently generate any random index without any fear or worry about encountering a collision. It also matches the uuid size which is 16 bytes. So that hopefully is compatible with more use cases I guess. Then a two byte MAC is a like a forward compatibility or forward thinking size to improve performance.

So here we have the construction of a Jamtis normal enote. So with Jamtis we have two kinds of enotes — we have normal enotes and we have self-sending notes, and I’ll get into why we have that distinction later. So if we’re given a user’s address which has the address keys and the address tag, we have an amount and we have this input context. So the input context is an interesting addition I’ll say for now. So the input context normally it’s just a hash of all the key images that are inputs to the transaction that will create this enote. If it’s a coinbase-transaction, then it’ll be a hash of the block height of this coinbase. So we have the ephemeral key of the enote, which is ephemeral private key times the base key, the base Diffie-Hellman key here, as we see, the base key specified by the user. Instead of the generator like you normally get with Diffie-Hellman you have the user-defined base key for the ephemeral public key. You also have the Diffie-Hellman derivation which is this the secret in the Diffie-Hellman exchange between the ephemeral private key and the Diffie-Hellman public key defined by in the user address. You have a sender-receiver secret, which is a function of the Diffie-Hellman derivation. We also include the ephemeral public key for robustness and it includes the input context. So the sender-receiver secret is bound to the inputs of the transaction. Since input contexts are always unique, because key images and coinbase heights are always unique, your sender-receiver secrets are always unique, this means the resulting pieces of your enote will always be unique on the chain, unless your enote is malformed. But if the enote is malformed then the user will not discover that enote when they go to scan the chain.

So let’s go back to this. As usual we have the amount commitment, the encoded amount, the one-time address — these three are basically the same as what we get with the RingCT with an extension or with the sender-receiver secret, although the one-time address we include, the amount commitment bound into the one-time address to ensure that even in contexts where the input context is malformed, but the user acquires that input context from a malicious source of ledger data, so like a third party scanner or whoever is feeding your node information or whatever. If they collaborate with an enote constructor to give you a bad input context that you discover, and you say: “I believe I own this”, even though in reality the input context doesn’t match the inputs of the transaction and are actually matching the inputs of a different transaction, which could allow the sender-receiver secret to be a duplicate of what could be found in another transaction, even in that case the one-time address will only be duplicated, if the amount commitment itself is duplicated. So only if the exact same amount is in this enote will the one-time address as in the previous the other transaction that I’ve been alluding to will the one-time address be duplicated. This means that if there are duplicate enotes in the chain their amounts are guaranteed to be the same. If a user is able to discover duplicate enotes, it’s guaranteed that their amounts will be the same. So we also encrypt the address tag and put it in the enote, and we also have the view tag as usual.

So now we can talk about self-send enotes. So these are when you construct a transaction most of the time you add a change output, sometimes you add a dummy output, but these are all things that you create yourself and send to yourself really. So we have the power to customize the construction of these enotes to have more up to a better control of information recovery, which we’ll talk about later.

So here I put asterisks by the components that are constructed differently. So we have the sender-receiver secret is different. So in this case we do not create a Diffie-Hellman exchange at all. We do not create a Diffie-Hellman derivation, aside from the view tag done at the bottom there, just for the view tag is the derivation created. For the sender-receiver secret there’s no derivation. Instead we do a keyed hash of some context information. The type of the self-send enote, the ephemeral pubkey which is stored in the enote and the input context are bound up with the view balance key. This means the recipient who created it for himself can reconstruct the sender-receiver secret without doing a Diffie-Hellman exchange. This lets him…

I actually forgot to talk about something. We have in the amount commitment and encoded amount, we include this, the foundation, you could call it the foundation of the Diffie-Hellman exchange. So that the Diffie-Hellman base key or reverse Diffie-Hellman key, which is the ephemeral private key times the generator G.

So basically the ephemeral pubkey can be considered a reverse ephemeral key of this key that gets baked into the amount commitment and encoded amount. So the user’s private key to go from the ephemeral public key to the this baked in key is one over the unlock-amounts key, which we can see here, so one over the unlock-amount key times the address private key. Oops… wrong direction. So it’s kind of a bi-directional ephemeral exchange I guess you could say.

But that’s not present here in the self-sending enotes, because the sender-receiver secret itself is bound to the view balance key, which is like the master of all viewing. So we don’t need to bake that in. So we have the amount commitment, encoded amount, the one-time address is the same here, in this case we do a raw encryption of the address tag, of the address index instead of encrypting the enote or the address tag, because the sender-receiver secret is bound again to the master view balance key or the core view balance key. So we can just raw encrypt the address index and get the same properties that we expect. So yeah then we have the view tag, which is the same as in the normal enote, we have the Diffie-Hellman key that goes into the view tag, then the Diffie-Hellman derivation that goes into the view tag again. I’ll also note that in both cases the encrypted address tag and the view tag are bound to the one-time address, and this helps to ensure uniqueness in all cases or in all and pretty much all cases. So the final enote we have, as discussed, amount commitment, encoded amount, one-time address, encrypted address tag, view tag and ephemeral pubkey.

All right, now we have the Jamtis keys or key images. In this case it’s different from how what we find in CryptoNote. So all of the pieces that are related to viewing are on the denominator, and the numerator is the master key. So the important thing here is if you know the master key times U it’s just a public key, a static public key, then if you have the view balance key, you can reconstruct all the things on the numerator and then do an inverse multiplied by your pre-stored master public key thing, and then you get the key image. So this is how we separate requirements for viewing and signing from each other. To view you need the view balance and this public key, to sign you need view balance and the master private key in order to sign in the key image. So the key image is also bound to all this other information — the amount commitment, ephemeral key, the index of the address, and the input context of the transaction.

Let’s see we’re running out of time, but I’ll just keep plugging away. So we have the two-output optimization to speed up balance recovery. So this is something that we also have with the current protocol, with RingCT. Most transactions only have two outputs — the destination, a normal destination, and a change sending funds back to yourself. And in some cases you also you have instead a dummy amount, which is like a zero amount as your amount change I guess. So for these cases we can optimize by only putting one ephemeral public key in the transaction instead of one per output we just have one that’s shared by the two outputs. This can be done when the second output is a self-send, so something you’re sending yourself, because in those cases you know the find-received key, so you can like rearrange in order to create the Diffie-Hellman derivation. So you get the ephemeral key for the non-self-send, so the normal destination, and then you just multiply your self-send or your own find-received key by that other ephemeral public key to get the Diffie-Hellman derivation for your transaction. For self-sends it’s only used for the view tag.

So is there a risk of duplication, which would impact privacy by reusing the ephemeral public key? So in the first place we’re only doing this if we have at least one self-send in a two output. So duplication can only occur if we have two self-sends that are the same type. Since we put the type of the self-send as a domain separator, the sender-receiver secret is bound to the type itself. So we’ll never get it. We can only get duplicated send-receiver secrets if we have the same type of self-sends in a transaction. So we need two same type self-send outputs. In transactions key images, not key images sorry, the one-time addresses of outputs must all be unique within a single transaction, not within the ledger, because that invites DDoS, but within a transaction all the one-time addresses must be unique, which means since the one-time address and the two tags are bound to the one-time address, all those must be unique, but the amount commitment could be duplicated, if you have the same type self-send, which is easy enough to avoid by banning two same type self-sends. It doesn’t make sense to have two change outputs anyway, so this is an easy thing to enforce. Note that you could have two same type self-sends with different amounts, and that might look like so that amount commitments are not identical, so maybe it’s okay, but since amounts are so small you can brute force equality of the mask itself. So it kind of doesn’t matter.

All right, so these are the rules for when you can add an additional or when you should add an additional output. All right, so what I’m trying to get at with this slide is the top thing here. So we want all transactions to have at least two outputs and at least one self-send output. And this is an important optimization that Justin helped me find. When we’re looking for our enotes that we have spent, when we’re trying to identify which ones we have spent, we only want to really look in transactions that we created. So if all of our transactions that we create have at least one self-send, this ensures that at least one output will be a view tag match, which means if we follow this rule, and then we only look in transactions that have at least one view tag match, look at the key images in those transactions, then we only need to look at those key images to find all the enotes that we have spent. I realize I’ve gone over time, so I’m gonna keep going until someone stops me. So this is an important optimization that reduces the amount of data that needs to be transmitted when we’re doing remote scanning.

All right, so Part 5 — we’ll talk about the actual workflow for balance recovery, which is more complicated than CryptoNote because we have more fine-grained control over the information access.

So the first piece of scanning is find-received. This is where you only have the find-received key this private k_fr here, private key. This is a like a pre-processing step for scanning. This is the most expensive piece by far, the most expensive piece of scanning is this pre-processing step. So what we do is we make our Diffie-Hellman derivation as usual, and so this Diffie-Hellman derivation will be the same for normal and self-sends. So the next step where we do the view tag check will be the same for normal outputs and self-sends, your normal enotes and self-sends. Importantly if our transaction has two outputs, then we’ll only compute the Diffie-Hellman derivation once for that transaction. So that’s where the two outputs optimization comes in. We only do this Diffie-Hellman derivation once for a two outputs transaction.

So once we got the derivation we make our view tag, we abort if it fails, if we can’t reproduce it. And then we create the normal sender-receiver secret and we use this to decrypt the encrypted address tag that’s stored in the enote on the ledger. So we now have a nominal address tag. The find-received key itself can’t decrypt or decipher the address tag to find the address index inside it. But the address tag itself is a static value for the address that owns the enote. So it’s possible for whoever has the find-received key to match address tags against a set of saved or known addresses that the user has. This can be used to notify a non-local user, when they’ve potentially received an output by matching the address tag against a predefined list, right.

So now we have view balance scanning, the normal process. So this is the first thing you do, when you received an enote that was flagged by the find-receives process. So I won’t get deeply into the other tiers, but they’re noted on the left side there. So here we have the view-balance private key and the master public key, and of course we can use the view-balance key to derive all the other private keys that go into a balance recovery. So we have a nominal or nominally owned enote flagged by the find-received process, and we want to see is it actually owned by us. So the first thing we do is we decipher the address tag to get the address index. And it turns out this is extremely efficient step, because deciphering is extremely fast compared to elliptic curve operations. So we decipher the nominal tag that was provided to us by the find-received scan. And if deciphering fails, then we abort. So since the MAC is two bytes here, at this point we’ve gone through three whole bytes of filtering. So the vast majority of the time if we get through those three bytes of filtering, so the view tag and then the address tag, we go to through those two steps we probably own the enote. So the rest of the scanning is not done for very many of the enotes in the ledger that we don’t own, I guess you could say.

So deciphering the address tag has really two important impacts on the scanning process. One is the MAC is an important filter for efficiency when handling information received from the find-received scan process, which greatly impacts the speed of balance recovery for a local user, who’s downloading pre-scanned information from a find-received service or whatever. And also it gives us the address index itself, which means we can do the rest of balance recovery directly from this address index without needing to have a pre-generated list of addresses to compare against, since we can just use the address index itself directly to reconstruct everything.

All right, so let’s continue. So we make the sender-receiver secret as you’d expect to be created. So in this case we can either reuse the Diffie-Hellman derivation, if we still have it, or we can recreate itб if it’s been lost. So we don’t want to transmit the Diffie-Hellman or the sender-receiver secret over the wire. So the fine-received information doesn’t include it, and it’s very cheap to, once we get through the address index filter, it’s very cheap to reconstruct the Diffie-Hellman derivation. So we get the sender- receiver secret and we use the deciphered address index to reconstruct the one-time address of the enote that we might own. If we fail to reconstruct the one-time address, then we abort, because I guess the filtering didn’t succeed, so we don’t own this.

So here we have a dashed line with an ugly little note that says: “Find-received plus generate-address”. So you can get up to this line with just the find-received key and the generate-address key, because with the generate-address we can reconstruct the one-time address with just this spend key extension and the sender-receiver secret, because we have the k_vb X plus k_m U, so if you combine these two wallet tiers you only get up to this point in the scanning process. So that addition of the unlock-amounts key was an important thing to do, because without the unlock-amounts key you could go all the way down to the second blue line below, the amount recovery, on which I’ll continue to talk about later in a bit. So the unlock-amounts key gets you down to this line and then adding or acquiring the unlock-amount key gets you down to this line, but without the unlock-amounts key you only get to this line here, where you identify which address index owns the enote, which matches against the what you’d expect from the power of those two keys. So the generate-address can look at addresses and the find-receive key can show you the nominal address of an enote that was constructed normally. So non-self-sends, only normal enotes.

All right. So now we have continuing on — we have the amount recovery. So here we have this baked key that I was talking about, this kind of a reverse Diffie-Hellman exchange with the inverse of the of the of k of K_e in the address, the Diffie-Hellman base key of the user, of the recipient. We do the inverse on the ephemeral key to get the ephemeral base key or whatever it should be called, the baked key, in order to decipher the amounts and reconstruct the amount commitment. So this reverse Diffie-Hellman has two important things — one the ability to read the amounts on the unlock-amounts key in addition of course to the generate-address key for the address index modifier. So in addition to getting information access, it defeats the Janus attack, that is the CryptoNote with subaddresses is vulnerable to. So as I recap the Janus attack is basically you can associate two subaddresses with each other, if you maliciously construct an enote, you can construct it from components of two different subaddresses. And then if the user recovers that and then notifies the sender that they received, then the sender will know that the two subaddresses they use to construct the enote are from the same user. In our case we reconstruct everything from the address index itself. So the address index, that we got from the address tag is used to reconstruct the one-time address and the amount commitment. So it’s impossible to combine two separate addresses to construct an enote that can be successfully recovered. So this kind of this little trick with the inverse Diffie-Hellman is very powerful.

Okay, so then up this blue line is what a payment validator can do, so this is the find-received tier, wallet tier, so with the payment validator they have the generate-address, find-received and unlock-amount keys, and then this public key that can be used for the reconstructing the amount, the one-time address. So up to this point the payment validator can find all normal enotes sent to the user and read the address index and the amount.

Oh, another thing about the address index. Since it’s 16 bytes this lets us more easily deprecate the payment ID system, because it’s kind of like squeezes the payment ID into the address index itself. And we’ll just talk about that more later, I think.

But so continuing on key images. Now this is the thing that only the view balance key can do. Since our one-time address is the on the X segment contains the view balance key. In order to move this chunk here that on the X and invert it onto the U segment here with key image, so key image is the inverse of all this viewing stuff times the static spend key. So if you have the view balance key then you can construct the key image. So if the key image appears on chain, then the enote is spent and you can know that with the view balance key, which of course can be used as I said here to derive all the other keys, unlock all the other information, all the rest of the information, and give you the key image. So the result of this is the enote, ephemeral key, input context, amount index, key image and you can just say that it’s a normal type, because you’ve succeeded this far.

So now we continuing with self-send balance recovery. So well I’ll get into how we the cycle that gets us here in a few slides. So we’re going to look at an enote that might be a self-send. So it’s a view tag match in a transaction with one of our key images. So it’s a key image from an enote that prior to this enote, some prior enote that we own, produced a key image that showed up in this transaction. And this transaction has a view tag match. So we know it could be a self-send. So around we’re going to look at it as a potentially a self-send. So we just can just say we have a normal enote with a ephemeral key input context. If we got information from the find-receive step, the only additional piece would be the nominal address tag, but that’s not going to be used for this piece of scanning.

So the first thing we do is we just do a hash, a keyed hash of the ephemeral key input context and a self-send type that we’re going to test, because there can be multiple types. So we have change, we have dummies, dummy self-sends, if there’s a zero amount change, or self-spends where we’re like churning money to ourselves. We have these three distinctions right now. So we’d have to test all three, but it’s a cheap thing to do, because the next thing we do after we have this the sender-receiver secret, we raw decrypt the address tag, so there’s no deciphering in here, we just raw decrypt it into the address index. And if the MAC is zero as expected, then we continue on, if it’s invalid, then we can try a new self-send type. So these two things are very cheap — we just do a hash and an XOR for all the types except for the occasional case where the MAC doesn’t fail even though we don’t own it, in which case we’ll do a reconstruction of the one-time address, which is just the same thing as we had with a normal scanning, with the reconstruction. If this fails, then we abort or try a new self-send type, if it doesn’t fail then we probably own, unless something horrible happened during a construction of the enote.

So now we do amount recovery. There’s no baked key I guess, there’s no Janus attack here. Janus doesn’t make sense I don’t know why I have that note there. But there’s no baked key here, because the sender-receiver secret is already a function of the view balance key, so if we can get this far, then there’s no question about information access, because only the view balance key can do this self-send scanning piece. So we decrypt them out, reconstruct the amount commitment just to make sure it’s well formed, and recreate the key image as we did before, do the key image check, and if we find the key image somewhere, then the enote is spent. So the same result ephemeral key input context,  amount index,  key image and in this case we have the self-send type that succeeded.

All right. So now we have the last two slides where it all comes together into the process, by which we process the ledger, the information in the ledger. I implemented it as a scanning of chunks. So we have a chunk which is just some set of transactions either from a range of blocks or maybe it’s the transaction pool, maybe some off-chain context that we’re using for like atomic swaps or something. So we find-receive scanned this chunk of transactions and the result find-receive scanning all the enotes in those transactions. So we have basic enote records, which are just enotes, the past view tag matches, and they also include the nominal address tag for the find-receive step created, and also some context information about where those enote records came from. And then from the transactions that have view tag matches, so all the enotes in the found enotes vector for each of those transactions we record the key images and along with where they came from. So then when we go further, process the chunks so this is the view balance, we’re now gonna complete or finish scanning the chunk. So first we look at the key images in the chunk, and we say are any of the old enotes that we have stored in our local wallet, have any of those been spent in this chunk. If they did, then we store the transaction ID of where those were spent.

Then we normal scan, we don’t do a normal scan on all the found enotes in the chunk, which is very fast, because of the address tag deciphering. If any of the normal scanned enotes in the chunk are spent, then we store the transaction ID. And then we look at all the transaction IDs that were flagged as having spend key images. So all the transactions with spend key images are transactions that we constructed, so they might have a self-send in them. So we loop on the stored IDs to scan all the view tag matches in those flagged transactions for self-send enotes. Again it’s fast because of the address tag or decryption. If any of the self-send enotes are spent later in the chunk, then we loop again to get through all the whole chunk to make sure we didn’t miss anything. So that’s how we process a chunk.

When we’re talking about the ledger itself, we’re processing one chunk at a time, so it’s like a composition of the chunk processing. So we have a ledger chunk, which is just an enote chunk, a chunk of find-receive scanned enotes from a range of blocks. We also record the block ID of the block that comes before the block range, so that we can check that each chunk is contiguous with the next chunk when we’re scanning, just in case of reorgs that happen during the scanning process. And also it allows us to do a contiguity check with our locally stored block IDs in case a reorg went into the stored blocks that we’ve already scanned or whatever.

All right. So then when we scan, we scan chunks of enotes from the ledger until there are no more chunks. And of course we do chunks instead of just doing the whole thing, because just as an efficiency measure. We do contiguity checks, and we have to rescan if there are any miscontiguity, mismatches, because that means there was a reorg. So we have to go back and rescan. There’s some complications around whether you fully rescan or partially scan it’s kind of an implementation detail. After doing an on-chain loop, where we process the entire ledger with consecutive chunks, then we process all the transactions in the transaction pool as one chunk. And then we do another follow-up loop scanning the ledger. So we do a follow-up loop in case the unconfirmed chunk is stale. So it’s an asynchronous process, so a block could sneak in between this on-chain loop and the unconfirmed processing. So we’re doing a follow-up loop just to make sure that there’s nothing we missed, because we care about the unchained stuff more than unconfirmed. So it’s okay if the unconfirmed is stale. And then with all the things that we’ve scanned we update our local storage. We discard all of the pre-existing unconfirmed records that are above the point of alignment with the current chain, and then we replace and record and update everything. And that’s the end. All right.
